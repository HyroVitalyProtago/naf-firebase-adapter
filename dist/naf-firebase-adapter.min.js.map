{"version":3,"sources":["webpack:///webpack/bootstrap 6b5f9017269d6f4692a4","webpack:///./src/index.js","webpack:///./node_modules/firebase-key-encode/firebase-key-encode.js","webpack:///./src/WebRtcPeer.js"],"names":[],"mappings":"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","file":"naf-firebase-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6b5f9017269d6f4692a4","const firebaseKeyEncode = require(\"firebase-key-encode\");\r\nconst WebRtcPeer = require(\"./WebRtcPeer\");\r\n\r\nclass FirebaseWebRtcAdapter {\r\n  /**\r\n    Config structure:\r\n    config.authType: none;\r\n    config.apiKey: your-api;\r\n    config.authDomain: your-project.firebaseapp.com;\r\n    config.databaseURL: https://your-project.firebaseio.com;\r\n  */\r\n  constructor(firebase, config) {\r\n    this.rootPath = \"networked-aframe\";\r\n\r\n    this.localId = null;\r\n    this.appId = null;\r\n    this.roomId = null;\r\n\r\n    this.peers = {}; // id -> WebRtcPeer\r\n    this.occupants = {}; // id -> joinTimestamp\r\n\r\n    config = config || window.firebaseConfig;\r\n    this.firebase = firebase || window.firebase;\r\n\r\n    if (this.firebase === undefined) {\r\n      throw new Error(\r\n        \"Import https://www.gstatic.com/firebasejs/x.x.x/firebase.js\"\r\n      );\r\n    }\r\n\r\n    this.authType = config.authType;\r\n    this.apiKey = config.apiKey;\r\n    this.authDomain = config.authDomain;\r\n    this.databaseURL = config.databaseURL;\r\n  }\r\n\r\n  /*\r\n   * Call before `connect`\r\n   */\r\n\r\n  setServerUrl(url) {\r\n    // handled in config\r\n  }\r\n\r\n  setApp(appId) {\r\n    this.appId = appId;\r\n  }\r\n\r\n  setRoom(roomId) {\r\n    this.roomId = roomId;\r\n  }\r\n\r\n  // options: { datachannel: bool, audio: bool }\r\n  setWebRtcOptions(options) {\r\n    // TODO: support audio and video\r\n    if (options.datachannel === false)\r\n      console.warn(\r\n        \"FirebaseWebRtcAdapter.setWebRtcOptions: datachannel must be true.\"\r\n      );\r\n    if (options.audio === true)\r\n      console.warn(\"FirebaseWebRtcAdapter does not support audio yet.\");\r\n    if (options.video === true)\r\n      console.warn(\"FirebaseWebRtcAdapter does not support video yet.\");\r\n  }\r\n\r\n  setServerConnectListeners(successListener, failureListener) {\r\n    this.connectSuccess = successListener;\r\n    this.connectFailure = failureListener;\r\n  }\r\n\r\n  setRoomOccupantListener(occupantListener) {\r\n    this.occupantListener = occupantListener;\r\n  }\r\n\r\n  setDataChannelListeners(openListener, closedListener, messageListener) {\r\n    this.openListener = openListener;\r\n    this.closedListener = closedListener;\r\n    this.messageListener = function(remoteId, dataType, data) {\r\n      var decodedData = firebaseKeyEncode.deepDecode(data);\r\n      messageListener(remoteId, dataType, decodedData);\r\n    };\r\n  }\r\n\r\n  connect() {\r\n    var self = this;\r\n\r\n    this.initFirebase(function(id) {\r\n      self.localId = id;\r\n      var firebaseApp = self.firebaseApp;\r\n\r\n      // Note: assuming that data transfer via firebase realtime database\r\n      //       is reliable and in order\r\n      // TODO: can race among peers? If so, fix\r\n\r\n      self.getTimestamp(function(timestamp) {\r\n        self.myRoomJoinTime = timestamp;\r\n\r\n        var userRef = firebaseApp\r\n          .database()\r\n          .ref(self.getUserPath(self.localId));\r\n        userRef.set({ timestamp: timestamp, signal: \"\", data: \"\" });\r\n        userRef.onDisconnect().remove();\r\n\r\n        var roomRef = firebaseApp.database().ref(self.getRoomPath());\r\n\r\n        roomRef.on(\"child_added\", function(data) {\r\n          var remoteId = data.key;\r\n\r\n          if (\r\n            remoteId === self.localId ||\r\n            remoteId === \"timestamp\" ||\r\n            self.peers[remoteId] !== undefined\r\n          )\r\n            return;\r\n\r\n          var remoteTimestamp = data.val().timestamp;\r\n\r\n          var peer = new WebRtcPeer(\r\n            self.localId,\r\n            remoteId,\r\n            // send signal function\r\n            function(data) {\r\n              firebaseApp\r\n                .database()\r\n                .ref(self.getSignalPath(self.localId))\r\n                .set(data);\r\n            }\r\n          );\r\n          peer.setDatachannelListeners(\r\n            self.openListener,\r\n            self.closedListener,\r\n            self.messageListener\r\n          );\r\n\r\n          self.peers[remoteId] = peer;\r\n          self.occupants[remoteId] = remoteTimestamp;\r\n\r\n          // received signal\r\n          firebaseApp\r\n            .database()\r\n            .ref(self.getSignalPath(remoteId))\r\n            .on(\"value\", function(data) {\r\n              var value = data.val();\r\n              if (value === null || value === \"\") return;\r\n              peer.handleSignal(value);\r\n            });\r\n\r\n          // received data\r\n          firebaseApp\r\n            .database()\r\n            .ref(self.getDataPath(remoteId))\r\n            .on(\"value\", function(data) {\r\n              var value = data.val();\r\n              if (value === null || value === \"\" || value.to !== self.localId)\r\n                return;\r\n              self.messageListener(remoteId, value.type, value.data);\r\n            });\r\n\r\n          // send offer from a peer who\r\n          //   - later joined the room, or\r\n          //   - has larger id if two peers joined the room at same time\r\n          if (\r\n            timestamp > remoteTimestamp ||\r\n            (timestamp === remoteTimestamp && self.localId > remoteId)\r\n          )\r\n            peer.offer();\r\n\r\n          self.occupantListener(self.occupants);\r\n        });\r\n\r\n        roomRef.on(\"child_removed\", function(data) {\r\n          var remoteId = data.key;\r\n\r\n          if (\r\n            remoteId === self.localId ||\r\n            remoteId === \"timestamp\" ||\r\n            self.peers[remoteId] === undefined\r\n          )\r\n            return;\r\n\r\n          delete self.peers[remoteId];\r\n          delete self.occupants[remoteId];\r\n\r\n          self.occupantListener(self.occupants);\r\n        });\r\n\r\n        self.connectSuccess(self.localId);\r\n      });\r\n    });\r\n  }\r\n\r\n  shouldStartConnectionTo(client) {\r\n    return (this.myRoomJoinTime || 0) <= (client ? client.roomJoinTime : 0);\r\n  }\r\n\r\n  startStreamConnection(clientId) {\r\n    // Handled by WebRtcPeer\r\n  }\r\n\r\n  closeStreamConnection(clientId) {\r\n    // Handled by WebRtcPeer\r\n  }\r\n\r\n  sendData(clientId, dataType, data) {\r\n    this.peers[clientId].send(dataType, data);\r\n  }\r\n\r\n  sendDataGuaranteed(clientId, dataType, data) {\r\n    var clonedData = JSON.parse(JSON.stringify(data));\r\n    var encodedData = firebaseKeyEncode.deepEncode(clonedData);\r\n    this.firebaseApp\r\n      .database()\r\n      .ref(this.getDataPath(this.localId))\r\n      .set({\r\n        to: clientId,\r\n        type: dataType,\r\n        data: encodedData\r\n      });\r\n  }\r\n\r\n  broadcastData(dataType, data) {\r\n    for (var clientId in this.peers) {\r\n      if (this.peers.hasOwnProperty(clientId)) {\r\n        this.sendData(clientId, dataType, data);\r\n      }\r\n    }\r\n  }\r\n\r\n  broadcastDataGuaranteed(dataType, data) {\r\n    for (var clientId in this.peers) {\r\n      if (this.peers.hasOwnProperty(clientId)) {\r\n        this.sendDataGuaranteed(clientId, dataType, data);\r\n      }\r\n    }\r\n  }\r\n\r\n  getConnectStatus(clientId) {\r\n    var peer = this.peers[clientId];\r\n\r\n    if (peer === undefined) return NAF.adapters.NOT_CONNECTED;\r\n\r\n    switch (peer.getStatus()) {\r\n      case WebRtcPeer.IS_CONNECTED:\r\n        return NAF.adapters.IS_CONNECTED;\r\n\r\n      case WebRtcPeer.CONNECTING:\r\n        return NAF.adapters.CONNECTING;\r\n\r\n      case WebRtcPeer.NOT_CONNECTED:\r\n      default:\r\n        return NAF.adapters.NOT_CONNECTED;\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Privates\r\n   */\r\n\r\n  initFirebase(callback) {\r\n    this.firebaseApp = this.firebase.initializeApp(\r\n      {\r\n        apiKey: this.apiKey,\r\n        authDomain: this.authDomain,\r\n        databaseURL: this.databaseURL\r\n      },\r\n      this.appId\r\n    );\r\n\r\n    this.auth(this.authType, callback);\r\n  }\r\n\r\n  auth(type, callback) {\r\n    switch (type) {\r\n      case \"none\":\r\n        this.authNone(callback);\r\n        break;\r\n\r\n      case \"anonymous\":\r\n        this.authAnonymous(callback);\r\n        break;\r\n\r\n      // TODO: support other auth type\r\n      default:\r\n        console.log(\"FirebaseWebRtcInterface.auth: Unknown authType \" + type);\r\n        break;\r\n    }\r\n  }\r\n\r\n  authNone(callback) {\r\n    var self = this;\r\n\r\n    // asynchronously invokes open listeners for the compatibility with other auth types.\r\n    // TODO: generate not just random but also unique id\r\n    requestAnimationFrame(function() {\r\n      callback(self.randomString());\r\n    });\r\n  }\r\n\r\n  authAnonymous(callback) {\r\n    var self = this;\r\n    var firebaseApp = this.firebaseApp;\r\n\r\n    firebaseApp\r\n      .auth()\r\n      .signInAnonymously()\r\n      .catch(function(error) {\r\n        console.error(\"FirebaseWebRtcInterface.authAnonymous: \" + error);\r\n        self.connectFailure(null, error);\r\n      });\r\n\r\n    firebaseApp.auth().onAuthStateChanged(function(user) {\r\n      if (user !== null) {\r\n        callback(user.uid);\r\n      }\r\n    });\r\n  }\r\n\r\n  /*\r\n   * realtime database layout\r\n   *\r\n   * /rootPath/appId/roomId/\r\n   *   - /userId/\r\n   *     - timestamp: joining the room timestamp\r\n   *     - signal: used to send signal\r\n   *     - data: used to send guaranteed data\r\n   *   - /timestamp/: working path to get timestamp\r\n   *     - userId: \r\n   */\r\n\r\n  getRootPath() {\r\n    return this.rootPath;\r\n  }\r\n\r\n  getAppPath() {\r\n    return this.getRootPath() + \"/\" + this.appId;\r\n  }\r\n\r\n  getRoomPath() {\r\n    return this.getAppPath() + \"/\" + this.roomId;\r\n  }\r\n\r\n  getUserPath(id) {\r\n    return this.getRoomPath() + \"/\" + id;\r\n  }\r\n\r\n  getSignalPath(id) {\r\n    return this.getUserPath(id) + \"/signal\";\r\n  }\r\n\r\n  getDataPath(id) {\r\n    return this.getUserPath(id) + \"/data\";\r\n  }\r\n\r\n  getTimestampGenerationPath(id) {\r\n    return this.getRoomPath() + \"/timestamp/\" + id;\r\n  }\r\n\r\n  randomString() {\r\n    var stringLength = 16;\r\n    var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz0123456789\";\r\n    var string = \"\";\r\n\r\n    for (var i = 0; i < stringLength; i++) {\r\n      var randomNumber = Math.floor(Math.random() * chars.length);\r\n      string += chars.substring(randomNumber, randomNumber + 1);\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  getTimestamp(callback) {\r\n    var firebaseApp = this.firebaseApp;\r\n    var ref = firebaseApp\r\n      .database()\r\n      .ref(this.getTimestampGenerationPath(this.localId));\r\n    ref.set(this.firebase.database.ServerValue.TIMESTAMP);\r\n    ref.once(\"value\", function(data) {\r\n      var timestamp = data.val();\r\n      ref.remove();\r\n      callback(timestamp);\r\n    });\r\n    ref.onDisconnect().remove();\r\n  }\r\n}\r\n\r\nNAF.adapters.register(\"firebase\", FirebaseWebRtcAdapter);\r\n\r\nmodule.exports = FirebaseWebRtcAdapter;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = {\r\n    encode: function (decoded) {\r\n        return encodeURIComponent(decoded).replace(/\\./g, '%2E');\r\n    },\r\n    decode: function (encoded) {\r\n        return decodeURIComponent(encoded.replace('%2E', '.'));\r\n    },\r\n    // Replaces the key with `fn(key)` on each key in an object tree.\r\n    // i.e. making all keys uppercase.\r\n    deepKeyReplace: function (obj, fn) {\r\n        var rebuiltTree = Object.assign({}, obj);\r\n\r\n        function traverse(o, x, func) {\r\n            if (typeof(o) === \"object\") {\r\n                for (var i in o) {\r\n                    if (o[i] !== null && (typeof(o[i])==\"object\" || Array.isArray(o[i]))) {\r\n                        //going on step down in the object tree!!\r\n                        traverse(o[i],x[i],func);\r\n                    }\r\n                    func.apply(this,[x, i, x[i]]);\r\n                }\r\n            } else if (Array.isArray(o)) {\r\n                for (var i = 0; i < o.length; i++) {\r\n                    // func.apply(this,[o, i,o[i]]);\r\n                    if (o[i] !== null && (typeof(o[i])==\"object\" || Array.isArray(o[i]))) {\r\n                        //going on step down in the object tree!!\r\n                        traverse(o[i], x[i], func);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        traverse(obj, rebuiltTree, function (parent, key, val) {\r\n            delete parent[key];\r\n            parent[fn(key)] = val;\r\n        });\r\n\r\n        return rebuiltTree;\r\n    },\r\n    deepDecode: function (encodedTree) {\r\n        var $this = this;\r\n\r\n        var rebuiltTree = this.deepKeyReplace(encodedTree, function (key) {\r\n            return $this.decode(key);\r\n        });\r\n\r\n        return rebuiltTree;\r\n    },\r\n    deepEncode: function (decodedTree) {\r\n        var $this = this;\r\n\r\n        var rebuiltTree = this.deepKeyReplace(decodedTree, function (key) {\r\n            return $this.encode(key);\r\n        });\r\n\r\n        return rebuiltTree;\r\n    }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/firebase-key-encode/firebase-key-encode.js\n// module id = 1\n// module chunks = 0","class WebRtcPeer {\r\n  constructor(localId, remoteId, sendSignalFunc) {\r\n    this.localId = localId;\r\n    this.remoteId = remoteId;\r\n    this.sendSignalFunc = sendSignalFunc;\r\n    this.open = false;\r\n    this.channelLabel = \"networked-aframe-channel\";\r\n\r\n    this.pc = this.createPeerConnection();\r\n    this.channel = null;\r\n  }\r\n\r\n  setDatachannelListeners(openListener, closedListener, messageListener) {\r\n    this.openListener = openListener;\r\n    this.closedListener = closedListener;\r\n    this.messageListener = messageListener;\r\n  }\r\n\r\n  offer() {\r\n    var self = this;\r\n    // reliable: false - UDP\r\n    this.setupChannel(\r\n      this.pc.createDataChannel(this.channelLabel, { reliable: false })\r\n    );\r\n    this.pc.createOffer(\r\n      function(sdp) {\r\n        self.handleSessionDescription(sdp);\r\n      },\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.offer: \" + error);\r\n      }\r\n    );\r\n  }\r\n\r\n  handleSignal(signal) {\r\n    // ignores signal if it isn't for me\r\n    if (this.localId !== signal.to || this.remoteId !== signal.from) return;\r\n\r\n    switch (signal.type) {\r\n      case \"offer\":\r\n        this.handleOffer(signal);\r\n        break;\r\n\r\n      case \"answer\":\r\n        this.handleAnswer(signal);\r\n        break;\r\n\r\n      case \"candidate\":\r\n        this.handleCandidate(signal);\r\n        break;\r\n\r\n      default:\r\n        console.error(\r\n          \"WebRtcPeer.handleSignal: Unknown signal type \" + signal.type\r\n        );\r\n        break;\r\n    }\r\n  }\r\n\r\n  send(type, data) {\r\n    // TODO: throw error?\r\n    if (this.channel === null || this.channel.readyState !== \"open\") return;\r\n\r\n    this.channel.send(JSON.stringify({ type: type, data: data }));\r\n  }\r\n\r\n  getStatus() {\r\n    if (this.channel === null) return WebRtcPeer.NOT_CONNECTED;\r\n\r\n    switch (this.channel.readyState) {\r\n      case \"open\":\r\n        return WebRtcPeer.IS_CONNECTED;\r\n\r\n      case \"connecting\":\r\n        return WebRtcPeer.CONNECTING;\r\n\r\n      case \"closing\":\r\n      case \"closed\":\r\n      default:\r\n        return WebRtcPeer.NOT_CONNECTED;\r\n    }\r\n  }\r\n\r\n  /*\r\n     * Privates\r\n     */\r\n\r\n  createPeerConnection() {\r\n    var self = this;\r\n    var RTCPeerConnection =\r\n      window.RTCPeerConnection ||\r\n      window.webkitRTCPeerConnection ||\r\n      window.mozRTCPeerConnection ||\r\n      window.msRTCPeerConnection;\r\n\r\n    if (RTCPeerConnection === undefined) {\r\n      throw new Error(\r\n        \"WebRtcPeer.createPeerConnection: This browser does not seem to support WebRTC.\"\r\n      );\r\n    }\r\n\r\n    var pc = new RTCPeerConnection({ iceServers: WebRtcPeer.ICE_SERVERS });\r\n\r\n    pc.onicecandidate = function(event) {\r\n      if (event.candidate) {\r\n        self.sendSignalFunc({\r\n          from: self.localId,\r\n          to: self.remoteId,\r\n          type: \"candidate\",\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          candidate: event.candidate.candidate\r\n        });\r\n      }\r\n    };\r\n\r\n    // Note: seems like channel.onclose hander is unreliable on some platforms,\r\n    //       so also tries to detect disconnection here.\r\n    pc.oniceconnectionstatechange = function() {\r\n      if (self.open && pc.iceConnectionState === \"disconnected\") {\r\n        self.open = false;\r\n        self.closedListener(self.remoteId);\r\n      }\r\n    };\r\n\r\n    return pc;\r\n  }\r\n\r\n  setupChannel(channel) {\r\n    var self = this;\r\n\r\n    this.channel = channel;\r\n\r\n    // received data from a remote peer\r\n    this.channel.onmessage = function(event) {\r\n      var data = JSON.parse(event.data);\r\n      self.messageListener(self.remoteId, data.type, data.data);\r\n    };\r\n\r\n    // connected with a remote peer\r\n    this.channel.onopen = function(event) {\r\n      self.open = true;\r\n      self.openListener(self.remoteId);\r\n    };\r\n\r\n    // disconnected with a remote peer\r\n    this.channel.onclose = function(event) {\r\n      if (!self.open) return;\r\n      self.open = false;\r\n      self.closedListener(self.remoteId);\r\n    };\r\n\r\n    // error occurred with a remote peer\r\n    this.channel.onerror = function(error) {\r\n      console.error(\"WebRtcPeer.channel.onerror: \" + error);\r\n    };\r\n  }\r\n\r\n  handleOffer(message) {\r\n    var self = this;\r\n\r\n    this.pc.ondatachannel = function(event) {\r\n      self.setupChannel(event.channel);\r\n    };\r\n\r\n    this.setRemoteDescription(message);\r\n\r\n    this.pc.createAnswer(\r\n      function(sdp) {\r\n        self.handleSessionDescription(sdp);\r\n      },\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.handleOffer: \" + error);\r\n      }\r\n    );\r\n  }\r\n\r\n  handleAnswer(message) {\r\n    this.setRemoteDescription(message);\r\n  }\r\n\r\n  handleCandidate(message) {\r\n    var self = this;\r\n    var RTCIceCandidate =\r\n      window.RTCIceCandidate ||\r\n      window.webkitRTCIceCandidate ||\r\n      window.mozRTCIceCandidate;\r\n\r\n    this.pc.addIceCandidate(\r\n      new RTCIceCandidate(message),\r\n      function() {},\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.handleCandidate: \" + error);\r\n      }\r\n    );\r\n  }\r\n\r\n  handleSessionDescription(sdp) {\r\n    var self = this;\r\n\r\n    this.pc.setLocalDescription(\r\n      sdp,\r\n      function() {},\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.handleSessionDescription: \" + error);\r\n      }\r\n    );\r\n\r\n    this.sendSignalFunc({\r\n      from: this.localId,\r\n      to: this.remoteId,\r\n      type: sdp.type,\r\n      sdp: sdp.sdp\r\n    });\r\n  }\r\n\r\n  setRemoteDescription(message) {\r\n    var self = this;\r\n    var RTCSessionDescription =\r\n      window.RTCSessionDescription ||\r\n      window.webkitRTCSessionDescription ||\r\n      window.mozRTCSessionDescription ||\r\n      window.msRTCSessionDescription;\r\n\r\n    this.pc.setRemoteDescription(\r\n      new RTCSessionDescription(message),\r\n      function() {},\r\n      function(error) {\r\n        console.error(\"WebRtcPeer.setRemoteDescription: \" + error);\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nWebRtcPeer.IS_CONNECTED = \"IS_CONNECTED\";\r\nWebRtcPeer.CONNECTING = \"CONNECTING\";\r\nWebRtcPeer.NOT_CONNECTED = \"NOT_CONNECTED\";\r\n\r\nWebRtcPeer.ICE_SERVERS = [\r\n  { urls: \"stun:stun1.l.google.com:19302\" },\r\n  { urls: \"stun:stun2.l.google.com:19302\" },\r\n  { urls: \"stun:stun3.l.google.com:19302\" },\r\n  { urls: \"stun:stun4.l.google.com:19302\" }\r\n];\r\n\r\nmodule.exports = WebRtcPeer;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/WebRtcPeer.js"],"sourceRoot":""}